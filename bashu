#!/bin/bash
# shellcheck shell=bash

# bashu
#
# This script provides a micro unit testing framework for bash
# scripts.

### Include guard

# Prevent the script from being loaded more than once.
[[ -n "${BASHU_INCLUDED+_}" ]] && return 0
readonly BASHU_INCLUDED=1

### Shell options

set -o nounset  # Same as `set -u`

### Global variables

# Note: what is meant by 'global variables' here is that they are used
# all over this library.

#### Constant variables

# Constant variable `bashu_self` is the filename of this
# library.
readonly bashu_self=$(readlink -f "${BASH_SOURCE[0]}")

# Constant variable `bashu_rootdir` is the directory name
# where this library resides.
readonly bashu_rootdir=$(dirname "$bashu_self")

# Constant variable `bashu_specfile` is the filename of the
# test script that loaded this library.
if _bashu_specfile=$(readlink -f "${BASH_SOURCE[1]}") &&\
    [[ -f "$_bashu_specfile" ]]; then
  :
elif _bashu_specfile=$(cd -- "$OLDPWD" && readlink -f "${BASH_SOURCE[1]}") &&\
    [[ -f "$_bashu_specfile" ]]; then
  :
else
  echo "error: unable to find a spec file: ${BASH_SOURCE[1]}" >&2
  exit 1
fi
readonly bashu_specfile=$_bashu_specfile

# Constant variable `bashu_fd_errtrap` is a file descriptor (FD) used
# by the function `bashu_errtrap`. The file object opened by the FD
# records the error code, the source and line number where the error
# is occurred. The initial value is dummy. In fact, it is set when
# beginning the test suite.
bashu_fd_errtrap=3

# Constant variable `bashu_fd_result` is a file descriptor (FD) used
# by the function `bashu_formatter`, which shows results of test cases
# to the user. The initial value is dummy. In fact, it is set when
# initializing the main process.
bashu_fd_result=4

# Constant variable `bashu_pid_formatter` is a process identifier
# (PID) of the asynchronous command, `bashu_formatter`. The initial
# value is dummy. Actual value is set when beginning the test suite.
bashu_pid_formatter=0

#### Boolean flags to control behavior

# Boolean flag `bashu_is_running` is set to 1 if the test suite is
# running.
bashu_is_running=0

#### Variables to manage states and to store results

# Array `bashu_all_testcases` contains all the function names
# defined in the test script.
bashu_all_testcases=()

# Array `bashu_performed_testcases` contains function names of
# performed test cases.
bashu_performed_testcases=()

# Array `bashu_passed_testcases` contains function names of passed test
# cases.
bashu_passed_testcases=()

# Array `bashu_failed_testcases` contains function names of failed test
# cases.
bashu_failed_testcases=()

# Array `bashu_err_trace_stack`
bashu_err_trace_stack=()

# Array `bashu_err_trace_stack_aux`
bashu_err_trace_stack_aux=()

# Array `bashu_err_status_stack`
bashu_err_status_stack=()


### Variables to store status and results of the current test case

# Variable `bashu_current_test` represents a function name of the
# current test case which is about to be run or being currently run.
bashu_current_test=

# Boolean flag `bashu_is_failed` is set to 1 if the current test
# case is failed.
bashu_is_failed=0

# Array `bashu_err_funcname` contains the names of functions in
# which a command returns a non-zero exit status.
bashu_err_funcname=()

# Array `bashu_err_source` contains the filenames where a command
# returns a non-zero exit status.
bashu_err_source=()

# Array `bashu_err_lineno` contains the line numbers in the source
# files where a command that returned a non-zero status is called.
bashu_err_lineno=()

# Variable `bashu_err_status` is the exit status value from the
# failed command.
bashu_err_status=


### Utility functions

# Utility function `print_var_defs` outputs the value of each argument
# so that it can be restored with `eval` command. To distinguish from
# variables that have already declared, an underscore is added to the
# head of each variable name.
print_var_defs() {
  local newline=1
  local arg

  if (( $# > 0 )) && [[ "$1" == "-n" ]]; then
    newline=0
    shift
  fi

  for arg in "$@"; do
    printf "%s; " "$(declare -p "$arg" | sed "s/${arg}=/_${arg}=/")"
  done

  if (( newline )); then
    printf "\n"
  fi
}

# Utility function `copy_func` takes exactly two arguments, and it
# declares a function with the second argument which have the same
# functionality as the function with the first argument.
# The code is taken from:
#   https://stackoverflow.com/a/18839557/14398042
copy_function() {
  test -n "$(declare -f "$1")" || return
  eval "${_/$1/$2}"
}


### ERR trap handler

# Function `bashu_errtrap` is executed whenever a command in each
# test case returns a non-zero exit status. It outputs the name of
# function, the line number and the source filename where the command
# failed and the exit status value to the file descriptor desginated
# by `bashu_fd_errtrap`. Then exits with the error status.
# shellcheck disable=SC2034
_bashu_errtrap() {
  local status=$1
  local n=0
  local s=${2:-1}

  # Count the number of error stack.
  until [[ "${FUNCNAME[$((n + s + 1))]}" == "bashu_run_in_subshell" ]]; do
    n=$((n + 1))
  done
  err_funcname=("${FUNCNAME[@]:$((s + 1)):$n}")
  err_source=("${BASH_SOURCE[@]:$((s + 1)):$n}")
  err_lineno=("${BASH_LINENO[@]:$s:$n}")
  err_status=$status
  print_var_defs "err_funcname" "err_source" "err_lineno" "err_status" >&$bashu_fd_errtrap

  # Print info for debug purpose.
  # echo
  # echo "n=$n"
  # echo "s=$s"
  # echo "status=$status"
  # echo "FUNCNAME[${#FUNCNAME[@]}]=${FUNCNAME[*]}"
  # echo "BASH_SOURCE[${#BASH_SOURCE[@]}]=${BASH_SOURCE[*]}"
  # echo "BASH_LINENO[${#BASH_LINENO[@]}]=${BASH_LINENO[*]}"
  # echo "err_funcname[${#err_funcname[@]}]=${err_funcname[*]}"
  # echo "err_source[${#err_source[@]}]=${err_source[*]}"
  # echo "err_lineno[${#err_lineno[@]}]=${err_lineno[*]}"
  # echo "err_status=$err_status"
  # echo "--"
}

bashu_errtrap() {
  local status=$?

  _bashu_errtrap $status
  exit $status
}


### EXIT trap handler

# Function `bashu_exittrap` is executed on exit from the shell. Close
# file descriptors if they are still open especially when the shell
# exits unexpectedly.
bashu_exittrap() {
  [[ ! -t $bashu_fd_errtrap ]] && exec {bashu_fd_errtrap}>&-
  [[ ! -t $bashu_fd_result ]] && exec {bashu_fd_result}>&-
}

trap 'bashu_exittrap' EXIT


### Global initializer

# Function `bashu_initialize` works as a global initializer, which
# means it is called once at start of the main process.
bashu_initialize() {
  bashu_is_running=0
  bashu_all_testcases=()
  bashu_performed_testcases=()
  bashu_passed_testcases=()
  bashu_failed_testcases=()
  bashu_err_trace_stack=()
  bashu_err_trace_stack_aux=()
  bashu_err_status_stack=()
  exec {bashu_fd_result}<> <(:)
  bashu_formatter &
  bashu_pid_formatter=$!
}


### Argument parser

# Function `bashu_parse` parses arguments provided by the user and
# changes behevior of the main process.
bashu_parse() {
  :
}


### Test suite runner

# Function `bashu_collect_all_testcases` collects function names
# which start with "testcase_".
# shellcheck disable=SC2120
bashu_collect_all_testcases() {
  local specfile=${1:-${bashu_specfile}}
  local pattern_find_testcase="^[^#\n]*\(function[[:space:]]\+testcase_[-_:[:alnum:]]\+\|^[ \t]*testcase_[-_:[:alnum:]]\+[ \t]*()\)"
  local pattern_remove_function_keyword="[[:space:]]*(|function[[:space:]]+)"
  local pattern_remove_parentheses="[[:space:]]*\(\)"
  local funcname

  while IFS= read -r funcname; do
    bashu_all_testcases+=("${funcname#*:}")
  done < <(grep -on --color=never "$pattern_find_testcase" "$specfile" | sed -E -e "s/:$pattern_remove_function_keyword/:/g" -e "s/$pattern_remove_parentheses//g")
}

# Function `bashu_begin_test_suite` prepares to run a test suite.
bashu_begin_test_suite() {
  bashu_is_running=1
  exec {bashu_fd_errtrap}<> <(:)
}

# Function `bashu_finish_test_suite` finishes running the test suite.
bashu_finish_test_suite() {
  bashu_is_running=0
  exec {bashu_fd_errtrap}>&-
}

# Function `bashu_run_testcases` executes the specified test cases.
bashu_run_testcases() {
  local testcase

  bashu_begin_test_suite
  for testcase in "${bashu_all_testcases[@]}"; do
    bashu_run_a_testcase "$testcase"
  done
  bashu_finish_test_suite
}

# Function `bashu_dump_summary` prints the summary of the test suite.
# shellcheck disable=SC2120
bashu_dump_summary() {
  local fd=${1:-$bashu_fd_result}

  print_var_defs \
    "bashu_is_running" \
    "bashu_all_testcases" "bashu_performed_testcases" \
    "bashu_passed_testcases" "bashu_failed_testcases" >&"$fd"
}

# Function `bashu_run` executes the main process.
bashu_run() {
  declare -i status
  bashu_collect_all_testcases
  bashu_run_testcases
  bashu_dump_summary
  status="${#bashu_failed_testcases[@]}"
  return $status
}


### Test case runner

# Function `bashu_preprocess` prepares to run a test case. It takes
# the name of the current test case as the first argument.
bashu_preprocess() {
  # Set the current test case.
  bashu_current_test=$1

  # Set up variables.
  bashu_is_failed=0
  bashu_err_funcname=()
  bashu_err_source=()
  bashu_err_lineno=()
  bashu_err_status=
}

# Helper function `_bashu_put_err_trace` puts an error trace of the
# current failed test to a variable whose name is the first argument.
_bashu_put_err_trace() {
  local err_funcname=("${_err_funcname[@]}")
  local err_source=("${_err_source[@]}")
  local err_lineno=("${_err_lineno[@]}")
  for ((i=0; i<${#err_funcname[@]}; i++)); do
    err_trace+=("${err_funcname[$i]}:${err_source[$i]}:${err_lineno[$i]}")
  done
  eval "$(declare -p err_trace | sed "s/err_trace=/${1}=/")"
}

# Function `bashu_postprocess` finishes running the test case. It
# takes the exit status of the last command. If the current test case
# failed, it reads the error stack from the file descriptor
# `bashu_fd_errtrap` and set them to global variables.
bashu_postprocess() {
  local status=$1
  local _err_status=
  local err_trace=()

  bashu_performed_testcases+=("$bashu_current_test")
  if (( status )); then
    bashu_failed_testcases+=("$bashu_current_test")
    if ! read -r -t 0.2 v <&$bashu_fd_errtrap; then
      echo "internal error: nothing to read in \$bashu_fd_errtrap:$bashu_fd_errtrap" >&2
      return 1
    fi
    eval "$v"
    bashu_is_failed=1
    bashu_err_funcname=("${_err_funcname[@]}")
    bashu_err_source=("${_err_source[@]}")
    bashu_err_lineno=("${_err_lineno[@]}")
    bashu_err_status=$_err_status
    _bashu_put_err_trace err_trace
    bashu_err_trace_stack+=("${err_trace[@]}")
    bashu_err_trace_stack_aux+=("${#err_trace[@]}")
    bashu_err_status_stack+=("$_err_status")
  else
    bashu_passed_testcases+=("$bashu_current_test")
  fi
}

# Function `bashu_run_in_subshell` sums up commands that are executed
# in a subshell.
bashu_run_in_subshell() {
  set -o errexit -o errtrace
  trap 'bashu_errtrap' ERR
  $bashu_current_test
}

# Function `bashu_dump_result` prints the result of the current test
# case to the file descriptor `bashu_fd_result`.
# shellcheck disable=SC2120
bashu_dump_result() {
  local fd=${1:-$bashu_fd_result}

  print_var_defs -n "bashu_is_running" "bashu_current_test" "bashu_is_failed" >&"$fd"
  if (( bashu_is_failed )); then
    print_var_defs "bashu_err_funcname" "bashu_err_source" "bashu_err_lineno" "bashu_err_status" >&"$fd"
  else
    print_var_defs >&"$fd"
  fi
}

# Function `bashu_run_a_testcase` executes a sequence of each test
# case.
bashu_run_a_testcase() {
  local testcase=$1

  bashu_preprocess "$testcase"
  ( bashu_run_in_subshell )
  bashu_postprocess $?
  bashu_dump_result
}


### Destructor of the main process

# Function `bashu_cleanup` cleans up the residues after running the
# test suite.
bashu_cleanup() {
  exec {bashu_fd_result}>&-
  sleep 0
  if ps -p $bashu_pid_formatter >/dev/null; then
    kill $bashu_pid_formatter
  fi
}


### Entry point of the main process

bashu_main() {
  local status
  bashu_initialize
  bashu_parse "$@"
  bashu_run
  status=$?
  bashu_cleanup
  exit $status
}


### Formatter

bashu_formatter() {
  local _bashu_is_running=
  local _bashu_current_test=
  local _bashu_is_failed=
  local _bashu_err_funcname=()
  local _bashu_err_source=()
  local _bashu_err_lineno=()
  local _bashu_err_status=
  local _bashu_all_testcases=()
  local _bashu_performed_testcases=()
  local _bashu_passed_testcases=()
  local _bashu_failed_testcases=()

  while read -r -u $bashu_fd_result v; do
    eval "$v"
    bashu_is_running=$_bashu_is_running
    if (( bashu_is_running)); then
      bashu_current_test=$_bashu_current_test
      bashu_is_failed=$_bashu_is_failed
      if (( ! bashu_is_failed )); then
        printf "."
      else
        bashu_err_funcname=("${_bashu_err_funcname[@]}")
        bashu_err_source=("${_bashu_err_source[@]}")
        bashu_err_lineno=("${_bashu_err_lineno[@]}")
        bashu_err_status=$_bashu_err_status
        printf "F\n"
        echo "FAILED: $bashu_current_test"
        if (( ${#bashu_err_funcname[@]} > 0 )); then
          echo "  at ${bashu_err_lineno[0]} in ${bashu_err_source[0]} with $bashu_err_status"
        fi
        if (( ${#bashu_err_funcname[@]} > 1 )); then
          for (( i=1; i<${#bashu_err_funcname[@]}; i++ )); do
            echo "    called from ${bashu_err_lineno[$i]} in ${bashu_err_source[$i]}"
          done
        fi
      fi
    else
      bashu_all_testcases=("${_bashu_all_testcases[@]}")
      bashu_performed_testcases=("${_bashu_performed_testcases[@]}")
      bashu_passed_testcases=("${_bashu_passed_testcases[@]}")
      bashu_failed_testcases=("${_bashu_failed_testcases[@]}")
      local n_tests
      local n_failed
      n_tests=${#bashu_performed_testcases[@]}
      n_failed=${#bashu_failed_testcases[@]}
      echo
      echo "$n_tests tests, $n_failed failures"
    fi
  done
}
