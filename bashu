#!/bin/bash
# shellcheck shell=bash

# bashu
#
# This script provides a micro unit testing framework for bash
# scripts.

### Include guard

# Prevent the script from being loaded more than once.
[[ -n "${BASHU_INCLUDED+_}" ]] && return 0
readonly BASHU_INCLUDED=1

### Shell options

set -o nounset  # Same as `set -u`

### Global variables

# Note: what is meant by 'global variables' here is that they are used
# all over this library.

#### Constant variables

# Constant variable `bashu_self` is the filename of this
# library.
readonly bashu_self=$(readlink -f "${BASH_SOURCE[0]}")

# Constant variable `bashu_rootdir` is the directory name
# where this library resides.
readonly bashu_rootdir=$(dirname "$bashu_self")

# Constant variable `bashu_specfile` is the filename of the
# test script that loaded this library.
if _bashu_specfile=$(readlink -f "${BASH_SOURCE[1]}") &&\
    [[ -f "$_bashu_specfile" ]]; then
  :
elif _bashu_specfile=$(cd -- "$OLDPWD" && readlink -f "${BASH_SOURCE[1]}") &&\
    [[ -f "$_bashu_specfile" ]]; then
  :
else
  echo "error: unable to find a spec file: ${BASH_SOURCE[1]}" >&2
  exit 1
fi
readonly bashu_specfile=$_bashu_specfile

# Constant variable `bashu_fd_errtrap` is a file descriptor (FD) used
# by the function `bashu_errtrap`. The file object opened by the FD
# records the error code, the source and line number where the error
# is occurred. The initial value is dummy. In fact, it is set when
# beginning the test suite.
bashu_fd_errtrap=3

# Constant variable `bashu_fd_result` is a file descriptor (FD) used
# by the function `bashu_formatter`, which shows results of test cases
# to the user. The initial value is dummy. In fact, it is set when
# initializing the main process.
bashu_fd_result=4

# Constant variable `bashu_pid_formatter` is a process identifier
# (PID) of the asynchronous command, `bashu_formatter`. The initial
# value is dummy. Actual value is set when beginning the test suite.
bashu_pid_formatter=0

#### Boolean flags to control behavior

# Boolean flag `bashu_is_running` is set to 1 if the test suite is
# running.
bashu_is_running=0

#### Variables to manage states and to store results

# Array `bashu_all_testcases` contains all the function names
# defined in the test script.
bashu_all_testcases=()

# Array `bashu_performed_testcases` contains function names of
# performed test cases.
bashu_performed_testcases=()

# Array `bashu_passed_testcases` contains function names of passed test
# cases.
bashu_passed_testcases=()

# Array `bashu_failed_testcases` contains function names of failed test
# cases.
bashu_failed_testcases=()

# Array `bashu_err_trace_stack`
bashu_err_trace_stack=()

# Array `bashu_err_trace_stack_aux`
bashu_err_trace_stack_aux=()

# Array `bashu_err_status_stack`
bashu_err_status_stack=()


### Variables to store status and results of the current test case

# Variable `bashu_current_test` represents a function name of the
# current test case which is about to be run or being currently run.
bashu_current_test=

# Boolean flag `bashu_is_failed` is set to 1 if the current test
# case is failed.
bashu_is_failed=0

# Array `bashu_err_funcname` contains the names of functions in
# which a command returns a non-zero exit status.
bashu_err_funcname=()

# Array `bashu_err_source` contains the filenames where a command
# returns a non-zero exit status.
bashu_err_source=()

# Array `bashu_err_lineno` contains the line numbers in the source
# files where a command that returned a non-zero status is called.
bashu_err_lineno=()

# Variable `bashu_err_status` is the exit status value from the
# failed command.
bashu_err_status=


### Utility functions

# Helper function `_logfmt` takes how many call frames to go back as
# the first argument, and messages to print in the standard error.
_logfmt() {
  local level=$1
  local caller=$2
  shift 2
  printf "%s: %s: %s\n" "$level" "${FUNCNAME[$caller]}" "$*"
}

# Utility function `error` prints an error message to the standard
# error.
error() {
  _logfmt error 2 "$@" >&2
}

# Utility function `print_var_defs` outputs the value of each argument
# so that it can be restored with `eval` command. To distinguish from
# variables that have already declared, an underscore is added to the
# head of each variable name.
print_var_defs() {
  local newline=1
  local arg

  if (( $# > 0 )) && [[ "$1" == "-n" ]]; then
    newline=0
    shift
  fi

  for arg in "$@"; do
    printf "%s; " "$(declare -p "$arg" | sed "s/${arg}=/_${arg}=/")"
  done

  if (( newline )); then
    printf "\n"
  fi
}

# Utility function `copy_func` takes exactly two arguments, and it
# declares a function with the second argument which have the same
# functionality as the function with the first argument.
# The code is taken from:
#   https://stackoverflow.com/a/18839557/14398042
copy_function() {
  test -n "$(declare -f "$1")" || return
  eval "${_/$1/$2}"
}

_is_line_continueing() {
  local filename=$1
  local lineno=$2
  local line

  line="$(sed -n "${lineno}p" "$filename" | sed -e 's/#.*//' -e 's/[[:space:]]*$//')"
  if [[ "${line: -1}" == "\\" ]] || [[ "$line" == $'\n' ]] || [[ -z "$line" ]]; then
    return 0
  else
    return 1
  fi
}

# Utility function `extract_range_of_lines` extracts a range of lines
# from a specified file. When the ending line continues with a
# backslash, join subsequent lines until the command ends.
extract_range_of_lines() {
  local exact=0
  if [[ "$1" == "-exact" ]]; then
    exact=1
    shift
  fi

  local filename=$1
  local start=$2
  local end=$3

  if [[ -f "$filename" ]]; then
    while (( ! exact )) && _is_line_continueing "$filename" "$end"; do
      end=$(( end + 1 ))
    done
    sed -n "${start},${end}p" "$filename"
  elif [[ -d "$filename" ]]; then
    echo "bashu error: ${FUNCNAME[0]}: ${filename}: Is a directory" >&2
    return 21
  else
    echo "bashu error: ${FUNCNAME[0]}: ${filename}: No such file or directory" >&2
    return 2
  fi
}

# Utility function `find_function_location` prints the line number and
# the source file name where the provided function is defined.
find_function_location() {
  local funcname

  for funcname in "$@"; do
    if ! declare -f "$funcname" &>/dev/null; then
      echo "bashu error: ${FUNCNAME[0]}: ${funcname}: command not found" >&2
      return 127
    fi
  done

  shopt -s extdebug
  for funcname in "$@"; do
    declare -F "$funcname" | cut -f2-3 -d' '
  done
  shopt -u extdebug
}


### ERR trap handler

# Function `bashu_errtrap` is executed whenever a command in each
# test case returns a non-zero exit status. It outputs the name of
# function, the line number and the source filename where the command
# failed and the exit status value to the file descriptor desginated
# by `bashu_fd_errtrap`. Then exits with the error status.
# shellcheck disable=SC2034
_bashu_errtrap() {
  local status=$1
  local n=0
  local s=${2:-1}

  # Count the number of error stack.
  until [[ "${FUNCNAME[$((n + s + 1))]}" == "bashu_run_in_subshell" ]]; do
    n=$((n + 1))
  done
  err_funcname=("${FUNCNAME[@]:$((s + 1)):$n}")
  err_source=("${BASH_SOURCE[@]:$((s + 1)):$n}")
  err_lineno=("${BASH_LINENO[@]:$s:$n}")
  err_status=$status
  print_var_defs "err_funcname" "err_source" "err_lineno" "err_status" >&$bashu_fd_errtrap

  # Print info for debug purpose.
  # echo
  # echo "n=$n"
  # echo "s=$s"
  # echo "status=$status"
  # echo "FUNCNAME[${#FUNCNAME[@]}]=${FUNCNAME[*]}"
  # echo "BASH_SOURCE[${#BASH_SOURCE[@]}]=${BASH_SOURCE[*]}"
  # echo "BASH_LINENO[${#BASH_LINENO[@]}]=${BASH_LINENO[*]}"
  # echo "err_funcname[${#err_funcname[@]}]=${err_funcname[*]}"
  # echo "err_source[${#err_source[@]}]=${err_source[*]}"
  # echo "err_lineno[${#err_lineno[@]}]=${err_lineno[*]}"
  # echo "err_status=$err_status"
  # echo "--"
}

bashu_errtrap() {
  local status=$?

  _bashu_errtrap $status
  exit $status
}


### EXIT trap handler

# Function `bashu_exittrap` is executed on exit from the shell. Close
# file descriptors if they are still open especially when the shell
# exits unexpectedly.
bashu_exittrap() {
  [[ ! -t $bashu_fd_errtrap ]] && exec {bashu_fd_errtrap}>&-
  [[ ! -t $bashu_fd_result ]] && exec {bashu_fd_result}>&-
}

trap 'bashu_exittrap' EXIT


### Global initializer

# Function `bashu_initialize` works as a global initializer, which
# means it is called once at start of the main process.
_bashu_initialize() {
  bashu_is_running=0
  bashu_all_testcases=()
  bashu_performed_testcases=()
  bashu_passed_testcases=()
  bashu_failed_testcases=()
  bashu_err_trace_stack=()
  bashu_err_trace_stack_aux=()
  bashu_err_status_stack=()
}

bashu_initialize() {
  _bashu_initialize
  exec {bashu_fd_result}<> <(:)
  bashu_formatter "$bashu_fd_result" &
  bashu_pid_formatter=$!
}


### Argument parser

# Function `bashu_parse` parses arguments provided by the user and
# changes behevior of the main process.
bashu_parse() {
  :
}


### Test suite runner

# Function `bashu_collect_all_testcases` collects function names
# which start with "testcase_".
# shellcheck disable=SC2120
bashu_collect_all_testcases() {
  local specfile=${1:-${bashu_specfile}}
  local pattern_find_testcase="^[^#\n]*\(function[[:space:]]\+testcase_[-_:[:alnum:]]\+\|^[ \t]*testcase_[-_:[:alnum:]]\+[ \t]*()\)"
  local pattern_remove_function_keyword="[[:space:]]*(|function[[:space:]]+)"
  local pattern_remove_parentheses="[[:space:]]*\(\)"
  local funcname

  while IFS= read -r funcname; do
    bashu_all_testcases+=("${funcname#*:}")
  done < <(grep -on --color=never "$pattern_find_testcase" "$specfile" | sed -E -e "s/:$pattern_remove_function_keyword/:/g" -e "s/$pattern_remove_parentheses//g")
}

# Function `bashu_begin_test_suite` prepares to run a test suite.
bashu_begin_test_suite() {
  bashu_is_running=1
  exec {bashu_fd_errtrap}<> <(:)
}

# Function `bashu_finish_test_suite` finishes running the test suite.
bashu_finish_test_suite() {
  bashu_is_running=0
  exec {bashu_fd_errtrap}>&-
}

# Function `bashu_run_testcases` executes the specified test cases.
bashu_run_testcases() {
  local testcase

  bashu_begin_test_suite
  for testcase in "${bashu_all_testcases[@]}"; do
    bashu_run_a_testcase "$testcase"
  done
  bashu_finish_test_suite
}

# Function `bashu_dump_summary` prints the summary of the test suite.
# shellcheck disable=SC2120
bashu_dump_summary() {
  local fd=${1:-$bashu_fd_result}

  print_var_defs \
    "bashu_is_running" \
    "bashu_all_testcases" "bashu_performed_testcases" \
    "bashu_passed_testcases" "bashu_failed_testcases" \
    "bashu_err_trace_stack" "bashu_err_trace_stack_aux" \
    "bashu_err_status_stack" >&"$fd"
}

# Function `bashu_run` executes the main process.
bashu_run() {
  declare -i status
  bashu_collect_all_testcases
  bashu_run_testcases
  bashu_dump_summary
  status="${#bashu_failed_testcases[@]}"
  return "$status"
}


### Test case runner

# Function `bashu_err_trace_stack_add` adds the current error trace
# elements to the variable `bashu_err_trace_stack` and adds the number
# of the error trace elements to the variable
# `bashu_err_trace_stack_aux`.
bashu_err_trace_stack_add() {
  local i n
  local err_trace=()

  n=${#bashu_err_funcname[@]}
  for ((i=$((n-1)); i>=0; i--)); do
    err_trace+=("${bashu_current_test}:${bashu_err_funcname[$i]}:${bashu_err_source[$i]}:${bashu_err_lineno[$i]}")
  done
  bashu_err_trace_stack+=("${err_trace[@]}")
  bashu_err_trace_stack_aux+=("${#err_trace[@]}")
}

# Function `bashu_err_trace_stack_get` provides the i'th error trace
# with a variable whose name is supplied as the first argument.
bashu_err_trace_stack_get() {
  local index=$1
  local ___err_trace=()
  local i s n

  s=0
  for ((i=0; i<index; i++)); do
    s=$(( s + ${bashu_err_trace_stack_aux[$i]} ))
  done
  n=${bashu_err_trace_stack_aux[$index]}
  for ((i=s; i<$((s+n)); i++)); do
    ___err_trace+=("${bashu_err_trace_stack[$i]}")
  done
  eval "$2=(\"\${___err_trace[@]}\")"
}

# Function `bashu_err_trace_stack_cut` breaks an error trace info into
# parts and puts them into an array.
bashu_err_trace_stack_cut() {
  local errtrace="$1"
  local ___err_info=()

  # shellcheck disable=SC2034
  IFS=':' read -ra ___err_info <<< "$errtrace"
  eval "$2=(\"\${___err_info[@]}\")"
}

# Function `bashu_preprocess` prepares to run a test case. It takes
# the name of the current test case as the first argument.
bashu_preprocess() {
  # Set the current test case.
  bashu_current_test=$1

  # Set up variables.
  bashu_is_failed=0
  bashu_err_funcname=()
  bashu_err_source=()
  bashu_err_lineno=()
  bashu_err_status=
}

# Function `bashu_postprocess` finishes running the test case. It
# takes the exit status of the last command. If the current test case
# failed, it reads the error stack from the file descriptor
# `bashu_fd_errtrap` and set them to global variables.
bashu_postprocess() {
  local status=$1
  local _err_status=

  bashu_performed_testcases+=("$bashu_current_test")
  if (( status )); then
    bashu_failed_testcases+=("$bashu_current_test")
    if ! read -r -t 0.2 v <&$bashu_fd_errtrap; then
      echo "internal error: nothing to read in \$bashu_fd_errtrap:$bashu_fd_errtrap" >&2
      return 1
    fi
    eval "$v"
    bashu_is_failed=1
    bashu_err_funcname=("${_err_funcname[@]}")
    bashu_err_source=("${_err_source[@]}")
    bashu_err_lineno=("${_err_lineno[@]}")
    bashu_err_status=$_err_status
    bashu_err_trace_stack_add
    bashu_err_status_stack+=("$_err_status")
  else
    bashu_passed_testcases+=("$bashu_current_test")
  fi
}

# Function `bashu_run_in_subshell` sums up commands that are executed
# in a subshell.
bashu_run_in_subshell() {
  set -o errexit -o errtrace
  trap 'bashu_errtrap' ERR
  $bashu_current_test
}

# Function `bashu_dump_result` prints the result of the current test
# case to the file descriptor `bashu_fd_result`.
# shellcheck disable=SC2120
bashu_dump_result() {
  local fd=${1:-$bashu_fd_result}

  print_var_defs -n "bashu_is_running" "bashu_current_test" "bashu_is_failed" >&"$fd"
  if (( bashu_is_failed )); then
    print_var_defs "bashu_err_funcname" "bashu_err_source" "bashu_err_lineno" "bashu_err_status" >&"$fd"
  else
    print_var_defs >&"$fd"
  fi
}

# Function `bashu_run_a_testcase` executes a sequence of each test
# case.
bashu_run_a_testcase() {
  local testcase=$1

  bashu_preprocess "$testcase"
  ( bashu_run_in_subshell )
  bashu_postprocess $?
  bashu_dump_result
}


### Destructor of the main process

# Function `bashu_cleanup` cleans up the residues after running the
# test suite.
bashu_cleanup() {
  exec {bashu_fd_result}>&-
  sleep 0.1
  if ps -p $bashu_pid_formatter >/dev/null; then
    kill $bashu_pid_formatter
  fi
}


### Entry point of the main process

bashu_main() {
  local status
  bashu_initialize
  bashu_parse "$@"
  bashu_run
  status=$?
  bashu_cleanup
  exit $status
}


### Formatter

bashu_formatter() {
  bashu_formatter_default "$@"
}

bashu_formatter_default() {
  local fd=${1:-$bashu_fd_result}

  while read -r -u "$fd" v; do
    eval "$v"
    _bashu_formatter_default
  done
}

bashu_formatter_default_fifo=/tmp/bashufifo-$$
_bashu_formatter_default() {
  bashu_is_running=$_bashu_is_running
  rm -f "$bashu_formatter_default_fifo"
  if (( bashu_is_running )); then
    _bashu_formatter_result_default
  else
    _bashu_formatter_summary_default
  fi
}

_bashu_formatter_result_default() {
  bashu_current_test=$_bashu_current_test
  bashu_is_failed=$_bashu_is_failed
  if (( ! bashu_is_failed )); then
    printf "."
  else
    bashu_err_funcname=("${_bashu_err_funcname[@]}")
    bashu_err_source=("${_bashu_err_source[@]}")
    bashu_err_lineno=("${_bashu_err_lineno[@]}")
    bashu_err_status=$_bashu_err_status
    printf "F"
  fi
}

_bashu_formatter_summary_default() {
  bashu_all_testcases=("${_bashu_all_testcases[@]}")
  bashu_performed_testcases=("${_bashu_performed_testcases[@]}")
  bashu_passed_testcases=("${_bashu_passed_testcases[@]}")
  bashu_failed_testcases=("${_bashu_failed_testcases[@]}")
  bashu_err_trace_stack=("${_bashu_err_trace_stack[@]}")
  bashu_err_trace_stack_aux=("${_bashu_err_trace_stack_aux[@]}")
  bashu_err_status_stack=("${_bashu_err_status_stack[@]}")
  printf "\n"
  _bashu_formatter_summary_default_failures
  _bashu_formatter_summary_default_footer
}

_bashu_formatter_print_with_indent() {
  local indent=$1; shift
  local line

  while IFS= read -r line; do
    line=${indent}${line}
    # Remove trailing whitespaces.
    line=${line%"${line##*[![:space:]]}"}
    echo "$line"
  done < <(printf "%s\n" "$@")
}

_bashu_formatter_summary_default_show_failed_code() {
  local testcase=$1
  local funcname=$2
  local source=$3
  local lineno=$4
  local start
  local end
  local code
  local err_line

  start=$(find_function_location "$funcname" | cut -f1 -d' ')
  end=$(( lineno - 1 ))
  code=$(extract_range_of_lines "$source" "$start" "$end")
  err_line=$(extract_range_of_lines "$source" "$lineno" "$lineno")
  _bashu_formatter_print_with_indent "    " "$code"
  _bashu_formatter_print_with_indent ">   " "$err_line"
}

# Function `_bashu_formatter_normalize_command` accepts a specific
# line number and its source file and returns a string in which an
# inline comment is removed and whitespaces are trimmed.
_bashu_formatter_normalize_command() {
  local source=$1
  local lineno=$2
  local code

  code=$(extract_range_of_lines -exact "$source" "$lineno" "$lineno")
  # Remove inline comments.
  code="${code%%\#*}"
  # Remove leading whitespaces.
  code=${code#"${code%%[![:space:]]*}"}
  # Remove trailing whitespaces and backslashes.
  code=${code%"${code##*[!\\[:space:]]}"}
  echo "$code" | tr -s ' '
}

_bashu_formatter_redefine_failed_function() {
  local funcname=$1
  local code=$2
  local fifo=${3:-${bashu_formatter_default_fifo}}
  local funcdef
  local redefined_funcdef=""
  local lines=()
  local line
  local echoline
  local sedopts=()

  funcdef=$(declare -f "$funcname" | tr -s ' ')
  # Remove trailing whitespace.
  funcdef="${funcdef//\ $'\n'/$'\n'}"
  # Add ';' to the last command to match it with the regex pattern.
  funcdef="${funcdef/$'\n'\}/;$'\n'\}}"

  # Replace '[' and ']' with '\[' and '\]'.
  code="${code/\[/\\\[}"
  code="${code/\]/\\\]}"
  # Add '*;' to the end;
  code="${code}[^;]*;"

  # Find malicious codes in the function.
  mapfile -t lines < <(grep -on "$code" <<< "$funcdef")
  if (( ${#lines[@]} > 0 )); then
    for line in "${lines[@]}"; do
      echoline="${line#*:}"
      echoline="${echoline%;}"
      if [[ "$echoline" == *"\""* ]] && [[ "$echoline" != *"\$("* ]]; then
        # shellcheck disable=SC2001
        echoline=$(echo "$echoline" | sed 's/\"\([^\"]*\)\"/\"\\\\\"\1\\\\\"\"/g')
      fi
      sedopts+=('-e')
      sedopts+=("${line%%:*} i echo ${echoline} >${fifo};")
    done
    redefined_funcdef=$(sed "${sedopts[@]}" <<< "$funcdef")
    # Force to cause an error when the code starts with the function
    # `_bashu_errtrap` to avoid the infinite recurrsion.
    if [[ "$code" == "_bashu_errtrap"* ]]; then
      redefined_funcdef=${redefined_funcdef/"$2"/false}
    fi
  else
    echo "internal error: failed to find malicious code: grep -o \"$code\" <<< \"$funcdef\"" >&2
  fi
  echo "$redefined_funcdef"
}

_bashu_formatter_summary_default_evaluate() {
  local testcase=$1
  local funcname=$2
  local source=$3
  local lineno=$4
  local fifo=${5:-${bashu_formatter_default_fifo}}
  local malcode
  local evalfunc
  local line
  local lines=()

  malcode=$(_bashu_formatter_normalize_command "$source" "$lineno")
  evalfunc=$(_bashu_formatter_redefine_failed_function "$funcname" "$malcode" "$fifo")
  (
    trap - ERR  # Remove `_bashu_errtrap` on ERR trap.
    set -eE
    eval "$evalfunc"
    $testcase
  ) &
  while read -r line; do
    lines+=("$line")
  done < "$fifo"
  echo "${lines[-1]}"
}

_bashu_formatter_summary_default_show_evaluated_code() {
  local depth=0
  local E="E"
  local n=$#
  local err_info=()
  local start
  local code

  if (( n == 1 )); then
    bashu_err_trace_stack_cut "$1" "err_info"
  else
    shift 1
    for e in "$@"; do
      bashu_err_trace_stack_cut "$e" "err_info"
      if ((depth > 0)); then
        E="E$(printf '+%.0s' $(seq 1 $depth))"
      fi
      start=$(find_function_location "${err_info[1]}" | cut -f1 -d' ')
      code=$(extract_range_of_lines "${err_info[2]}" "${start}" "${err_info[3]}")
      _bashu_formatter_print_with_indent "$(printf "%-4s" "$E")" "$code"
      depth=$(( depth + 1 ))
    done
    E="E$(printf '+%.0s' $(seq 1 $depth))"
  fi
  code=$(_bashu_formatter_summary_default_evaluate "${err_info[@]}")
  _bashu_formatter_print_with_indent "$(printf "%-4s" "$E")" "$code"
}

_bashu_formatter_summary_default_each_failure() {
  local index=$1
  local err_trace=()
  local err_info=()

  bashu_err_trace_stack_get "$index" "err_trace"
  bashu_err_trace_stack_cut "${err_trace[0]}" "err_info"
  printf "__ %s __\n" "${err_info[0]}"
  printf "\n"
  _bashu_formatter_summary_default_show_failed_code "${err_info[@]}"
  _bashu_formatter_summary_default_show_evaluated_code "${err_trace[@]}"
  printf "\n"
  bashu_err_trace_stack_cut "${err_trace[-1]}" "err_info"
  printf "%s:%s: Exit with %d\n" "${err_info[2]}" "${err_info[3]}" "${bashu_err_status_stack[$index]}"
}

_bashu_formatter_summary_default_failures() {
  local n_failed=${#bashu_failed_testcases[@]}
  if (( n_failed )); then
    rm -f "$bashu_formatter_default_fifo"
    mkfifo "$bashu_formatter_default_fifo"
    printf "== FAILURES ==\n"
    for ((i=0; i<n_failed; i++)); do
      _bashu_formatter_summary_default_each_failure "$i"
    done
    rm -f "$bashu_formatter_default_fifo"
  fi
}

_bashu_formatter_summary_default_footer() {
  local n_failed=${#bashu_failed_testcases[@]}
  local n_passed=${#bashu_passed_testcases[@]}

  if (( ! n_passed )); then
    printf "%s failed\n" "$n_failed"
  elif (( ! n_failed )); then
    printf "%s passed\n" "$n_passed"
  else
    printf "%s failed, %s passed\n" "$n_failed" "$n_passed"
  fi
}
