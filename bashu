#!/bin/bash
# shellcheck shell=bash

# bashu
#
# This script provides a micro unit testing framework for bash
# scripts.

### Include guard

# Prevent the script from being loaded more than once.
[[ -n "${BASHU_INCLUDED+_}" ]] && return 0
readonly BASHU_INCLUDED=1

### Shell options

set -o nounset  # Same as `set -u`

### Global variables

# Note: what is meant by 'global variables' here is that they are used
# all over this library.

#### Constant variables

# Constant variable `bashu_self` is the filename of this
# library.
readonly bashu_self=$(readlink -f "${BASH_SOURCE[0]}")

# Constant variable `bashu_rootdir` is the directory name
# where this library resides.
readonly bashu_rootdir=$(dirname "$bashu_self")

# Constant variable `bashu_specfile` is the filename of the
# test script that loaded this library.
if _bashu_specfile=$(readlink -f "${BASH_SOURCE[1]}") &&\
    [[ -f "$_bashu_specfile" ]]; then
  :
elif _bashu_specfile=$(cd -- "$OLDPWD" && readlink -f "${BASH_SOURCE[1]}") &&\
    [[ -f "$_bashu_specfile" ]]; then
  :
else
  echo "error: unable to find a spec file: ${BASH_SOURCE[1]}" >&2
  exit 1
fi
readonly bashu_specfile=$_bashu_specfile

# Constant variable `bashu_fd_errtrap` is a file descriptor (FD)
# used by the function `bashu_errtrap`. The file object opened by
# ths FD records the error code, the source and line number where the
# error is occurred.
bashu_fd_errtrap=3

# Constant variable `bashu_fd_result` is a file descriptor (FD) used
# by the function `bashu_formatter`, which shows results of test cases
# to the user.
bashu_fd_result=4

#### Boolean flags to control behavior

# Boolean flag `bashu_is_running` is set to 1 if the test suite is
# running.
bashu_is_running=0

#### Variables to manage states and to store results

# Array `bashu_all_testcases` contains all the function names
# defined in the test script.
bashu_all_testcases=()

# Array `bashu_performed_testcases` contains function names of
# performed test cases.
bashu_performed_testcases=()

# Array `bashu_passed_testcases` contains function names of passed test
# cases.
bashu_passed_testcases=()

# Array `bashu_failed_testcases` contains function names of failed test
# cases.
bashu_failed_testcases=()


### Variables to store status and results of the current test case

# Variable `bashu_current_test` represents a function name of the
# current test case which is about to be run or being currently run.
bashu_current_test=

# Boolean flag `bashu_is_failed` is set to 1 if the current test
# case is failed.
bashu_is_failed=0

# Array `bashu_err_funcname` contains the names of functions in
# which a command returns a non-zero exit status.
bashu_err_funcname=()

# Array `bashu_err_source` contains the filenames where a command
# returns a non-zero exit status.
bashu_err_source=()

# Array `bashu_err_lineno` contains the line numbers in the source
# files where a command that returned a non-zero status is called.
bashu_err_lineno=()

# Variable `bashu_err_status` is the exit status value from the
# failed command.
bashu_err_status=


### Utility functions

# Utility function `_print_var_defs` outputs the value of each
# argument so that it can be restored with `eval` command. To
# distinguish from variables that have already declared, an underscore
# is added to the head of each variable name.
print_var_defs() {
  local newline=1
  local arg

  if (( $# > 0 )) && [[ "$1" == "-n" ]]; then
    newline=0
    shift
  fi

  for arg in "$@"; do
    printf "%s; " "$(declare -p "$arg" | sed "s/${arg}=/_${arg}=/")"
  done

  if (( newline )); then
    printf "\n"
  fi
}


### ERR trap handler

# Function `bashu_errtrap` is executed whenever a command in each
# test case returns a non-zero exit status. It outputs the name of
# function, the line number and the source filename where the command
# failed and the exit status value to the file descriptor desginated
# by `bashu_fd_errtrap`. Then exits with the error status.
# shellcheck disable=SC2034
bashu_errtrap() {
  local status=$?
  local n=0

  # Count the number of error stack.
  until [[ "${FUNCNAME[$((n + 1))]}" == "bashu_run_in_subshell" ]]; do
    n=$((n + 1))
  done
  err_funcname=("${FUNCNAME[@]:1:$n}")
  err_source=("${BASH_SOURCE[@]:1:$n}")
  err_lineno=("${BASH_LINENO[@]:0:$n}")
  err_status=$status

  print_var_defs "err_funcname" "err_source" "err_lineno" "err_status" >&$bashu_fd_errtrap
  exit $status
}


### EXIT trap handler

# Function `bashu_exittrap` is executed on exit from the shell. Close
# file descriptors if they are still open especially when the shell
# exits unexpectedly.
bashu_exittrap() {
  [[ ! -t $bashu_fd_errtrap ]] && exec {bashu_fd_errtrap}>&-
  [[ ! -t $bashu_fd_result ]] && exec {bashu_fd_result}>&-
}

trap 'bashu_exittrap' EXIT


### Global initializer

# Function `bashu_initialize` works as a global initializer, which
# means it is called once at start of the main process.
bashu_initialize() {
  bashu_is_running=0
  bashu_all_testcases=()
  bashu_performed_testcases=()
  bashu_passed_testcases=()
  bashu_failed_testcases=()
  exec {bashu_fd_result}<> <(:)
}


### Argument parser

# Function `bashu_parse` parses arguments provided by the user and
# changes behevior of the main process.
bashu_parse() {
  :
}


### Test suite runner

# Function `bashu_collect_all_testcases` collects function names
# which start with "testcase_".
# shellcheck disable=SC2120
bashu_collect_all_testcases() {
  local specfile=${1:-${bashu_specfile}}
  local pattern_find_testcase="^[^#\n]*\(function[[:space:]]\+testcase_[-_:[:alnum:]]\+\|^[ \t]*testcase_[-_:[:alnum:]]\+[ \t]*()\)"
  local pattern_remove_function_keyword="[[:space:]]*(|function[[:space:]]+)"
  local pattern_remove_parentheses="[[:space:]]*\(\)"
  local funcname

  while IFS= read -r funcname; do
    bashu_all_testcases+=("${funcname#*:}")
  done < <(grep -on --color=never "$pattern_find_testcase" "$specfile" | sed -E -e "s/:$pattern_remove_function_keyword/:/g" -e "s/$pattern_remove_parentheses//g")
}

# Function `bashu_begin_test_suite` prepares to run a test suite.
bashu_begin_test_suite() {
  bashu_is_running=1
  bashu_formatter &
  exec {bashu_fd_errtrap}<> <(:)
}

# Function `bashu_finish_test_suite` finishes running the test suite.
bashu_finish_test_suite() {
  bashu_is_running=0
  exec {bashu_fd_errtrap}>&-
}

### Test case runner

# Function `bashu_preprocess` prepares to run a test case. It takes
# the name of the current test case as the first argument.
bashu_preprocess() {
  # Set the current test case.
  bashu_current_test=$1

  # Set up variables.
  bashu_is_failed=0
  bashu_err_funcname=()
  bashu_err_source=()
  bashu_err_lineno=()
  bashu_err_status=
}

# Function `bashu_postprocess` finishes running the test case. It
# takes the exit status of the last command. If the current test case
# failed, it reads the error stack from the file descriptor
# `bashu_fd_errtrap` and set them to global variables.
bashu_postprocess() {
  local status=$1
  local _err_status=

  bashu_performed_testcases+=("$bashu_current_test")
  if (( status )); then
    bashu_failed_testcases+=("$bashu_current_test")
    read -r v <&$bashu_fd_errtrap
    eval "$v"
    bashu_is_failed=1
    bashu_err_funcname=("${_err_funcname[@]}")
    bashu_err_source=("${_err_source[@]}")
    bashu_err_lineno=("${_err_lineno[@]}")
    bashu_err_status=$_err_status
  else
    bashu_passed_testcases+=("$bashu_current_test")
  fi
}

# Function `bashu_run_in_subshell` sums up commands that are executed
# in a subshell.
bashu_run_in_subshell() {
  set -o errexit -o errtrace
  trap 'bashu_errtrap' ERR
  $bashu_current_test
}

# Function `bashu_dump_result` prints the result of the current test
# case to the file descriptor `bashu_fd_result`.
bashu_dump_result() {
  print_var_defs -n "bashu_is_running" "bashu_current_test" "bashu_is_failed" >&$bashu_fd_result
  if (( bashu_is_failed )); then
    print_var_defs "bashu_err_funcname" "bashu_err_source" "bashu_err_lineno" "bashu_err_status" >&$bashu_fd_result
  else
    print_var_defs >&$bashu_fd_result
  fi
}

# Function `bashu_run_a_testcase` executes a sequence of each test
# case.
bashu_run_a_testcase() {
  local testcase=$1

  bashu_preprocess "$testcase"
  ( bashu_run_in_subshell )
  bashu_postprocess $?
  bashu_dump_result
}

# Function `bashu_run_testcases` executes the specified test cases.
bashu_run_testcases() {
  local testcase

  bashu_begin_test_suite
  for testcase in "${bashu_all_testcases[@]}"; do
    bashu_run_a_testcase "$testcase"
  done
  bashu_finish_test_suite
}

# Function `bashu_dump_summary` prints the summary of the test suite.
bashu_dump_summary() {
  print_var_defs \
    "bashu_is_running" \
    "bashu_all_testcases" "bashu_performed_testcases" \
    "bashu_passed_testcases" "bashu_failed_testcases" >&$bashu_fd_result
}

# Function `bashu_run` executes the main process.
bashu_run() {
  bashu_collect_all_testcases
  bashu_run_testcases
  bashu_dump_summary
}

# Function `bashu_cleanup` cleans up the residues after running the
# test suite.
bashu_cleanup() {
  exec {bashu_fd_result}>&-
}

bashu_main() {
  bashu_initialize
  bashu_parse "$@"
  bashu_run
  bashu_cleanup
}

bashu_formatter() {
  local _bashu_is_running=
  local _bashu_current_test=
  local _bashu_is_failed=
  local _bashu_err_funcname=()
  local _bashu_err_source=()
  local _bashu_err_lineno=()
  local _bashu_err_status=
  local _bashu_all_testcases=()
  local _bashu_performed_testcases=()
  local _bashu_passed_testcases=()
  local _bashu_failed_testcases=()

  while read -r -u $bashu_fd_result v; do
    eval "$v"
    bashu_is_running=$_bashu_is_running
    if (( bashu_is_running)); then
      bashu_current_test=$_bashu_current_test
      bashu_is_failed=$_bashu_is_failed
      if (( ! bashu_is_failed )); then
        printf "."
      else
        bashu_err_funcname=("${_bashu_err_funcname[@]}")
        bashu_err_source=("${_bashu_err_source[@]}")
        bashu_err_lineno=("${_bashu_err_lineno[@]}")
        bashu_err_status=$_bashu_err_status
        printf "F\n"
        echo "FAILED: $bashu_current_test"
        echo "  at ${bashu_err_lineno[0]} in ${bashu_err_source[0]} with $bashu_err_status"
        if (( ${#bashu_err_funcname[@]} > 1 )); then
          for (( i=1; i<${#bashu_err_funcname[@]}; i++ )); do
            echo "    called from ${bashu_err_lineno[$i]} in ${bashu_err_source[$i]}"
          done
        fi
      fi
    else
      bashu_all_testcases=("${_bashu_all_testcases[@]}")
      bashu_performed_testcases=("${_bashu_performed_testcases[@]}")
      bashu_passed_testcases=("${_bashu_passed_testcases[@]}")
      bashu_failed_testcases=("${_bashu_failed_testcases[@]}")
      local n_tests
      local n_failed
      n_tests=${#bashu_performed_testcases[@]}
      n_failed=${#bashu_failed_testcases[@]}
      echo
      echo "$n_tests tests, $n_failed failures"
    fi
  done
}
